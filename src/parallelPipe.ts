'use strict';

/**
 * Run async `action` on data generated by `iterableInput` in `concurrentTasksLimit` concurrent processes
 */
export function parallelPipe<TInput, TOutput>(
	iterableInput: AsyncIterableIterator<TInput> | IterableIterator<TInput>,
	concurrentTasksLimit: number,
	action: (input: TInput, index: number) => Promise<TOutput> | TOutput
): AsyncIterableIterator<TOutput> {
	if (!iterableInput || typeof iterableInput.next !== 'function')
		throw new TypeError('iterableInput must be an Iterable Object');
	if (typeof concurrentTasksLimit !== 'number' || concurrentTasksLimit <= 0)
		throw new TypeError('concurrentTasksLimit argument must be a positive Number');
	if (typeof action !== 'function')
		throw new TypeError('action argument must be a Function');

	const runningTasks: Array<Promise<IteratorResult<TOutput>> | IteratorResult<TOutput>> = [];
	let inputDone = false;
	let inputIndex = 0;

	async function executeActionOnIterableInput(input: {
		done: boolean,
		value: TInput
	}): Promise<
		{ done: false, value: TOutput } |
		{ done: true, value: TOutput | undefined }
	> {
		const { done, value: inputValue } = input;
		if (done) {
			inputDone = true;

			const actionResult = inputValue !== undefined ?
				await action(inputValue, inputIndex++) :
				undefined;

			return { done, value: actionResult };
		}
		else {
			const actionResult = await action(inputValue, inputIndex++);
			return { done, value: actionResult };
		}
	}

	/**
	 * Create async tasks for data pulling from input generator, until the processing queue is full
	 */
	function pullFromInput() {
		while (runningTasks.length < concurrentTasksLimit && !inputDone) {
			const input = iterableInput.next();
			const processTask = Promise.resolve(input).then(executeActionOnIterableInput);

			runningTasks.push(processTask);
		}
	}

	return {
		async next() {
			// start processing input once output is requested
			if (!runningTasks.length)
				pullFromInput();

			if (!runningTasks.length)
				return { done: true, value: undefined };

			const firstRunningTask = runningTasks.splice(0, 1)[0];
			const { done, value } = await firstRunningTask;

			if (!done)
				pullFromInput();

			return { done, value };
		},
		[Symbol.asyncIterator]() {
			return this;
		}
	};
}
